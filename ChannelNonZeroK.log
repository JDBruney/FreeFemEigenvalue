-- FreeFem++ v4.9 (Tue, Apr 20, 2021 12:10:29 AM - git v4.9)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : //  laplace with matrix
    2 : verbosity=1;
    3 :
    4 : int nev = 2; //number of computed eigen value close to sigma
    5 : real amp = 0.0;   //amplitude of oscillation
    6 : int Wall = 1;
    7 : int Per1 = 2;
    8 : int Per2 = 3;
    9 : int Const= 4;
   10 : real length=1;
   11 : int Res = 100;   //Resolution of Solver
   12 :
   13 : // Define mesh boundaries
   14 : border Gamma1(t=length, 0){x=t; y=1-amp*cos(2*pi*t);label=Wall;}
   15 : border Gamma2(t=1-amp, 0){x=0; y=t;label=Per1;}
   16 : border Gamma3(t=0, length){x=t; y=0;label=Wall;}
   17 : border Gamma4(t=0, 1-amp){x=length; y=t;label=Per2;}
   18 :
   19 : // Mesh
   20 : mesh Th = buildmesh(Gamma1(floor(Res*length))+Gamma2(Res)+Gamma3(floor(Res*length))+Gamma4(Res));
   21 :
   22 : // Fespace
   23 : fespace Vh(Th,P2);
   24 : Vh<complex> u1,u2;
   25 : Vh ur,ui;
   26 : int n=u1.n;
   27 : complex[int] Bu1(n),Bu2(n);
   28 : complex[int] Au1(n),Au2(n);
   29 :
   30 : complex  sigma = 0; //  1.000+1i;
   31 : int K=2;
   32 :
   33 :
   34 : // Problem
   35 : // OP = A - sigma B ; // the shifted matrix
   36 : varf  op(u1,u2)= int2d(Th)( dx(u1)*dx(u2) + dy(u1)*dy(u2)  + 2i*K*u1*dx(u2)+ sigma*(u1*u2));
   37 : varf  a(u1,u2)= int2d(Th)(dx(u1)*dx(u2)+dy(u1)*dy(u2)+2i*K*u1*dx(u2));
   38 : varf b([u1],[u2]) = int2d(Th)(u1*u2);
   39 :
   40 :
   41 : matrix<complex> OP= op(Vh,Vh,solver=UMFPACK);
   42 : matrix<complex> A= a(Vh,Vh,solver=GMRES);
   43 : matrix<complex> B= b(Vh,Vh,solver=GMRES,eps=1e-20);
   44 :
   45 :  complex[int] ev(nev); // to store eigen value
   46 :  Vh<complex>[int] eV(nev);   // to store eigen vector
   47 :
   48 :  int k=EigenValue(OP,B,sigma=sigma,value=ev,vector=eV,
   49 :                  tol=1e-10,maxit=0,ncv=0);
   50 :
   51 :  k=min(k,nev); //  some time the number of converged eigen value
   52 :                // can be greater than nev;
   53 :
   54 :
   55 : //For Plotting
   56 :  for (int kk=0;kk<k;kk++)
   57 :  {
   58 :    int i=kk;
   59 :    u1=eV[i];
   60 :    complex v= ev[i];
   61 :    Bu1=B*u1[];
   62 :    Au1=A*u1[];
   63 :      //  The Rayleigh quotient lambda = x'Ax/x'Bx
   64 :      //  given the eigen value
   65 :    complex xAx = u1[]'*Au1 ;
   66 :    complex xBx = u1[]'*Bu1 ;
   67 :    //  A u = l * B u
   68 :    Bu1 =   v*Bu1;
   69 :    u1[] = Au1 -Bu1;
   70 :    if(norm(u1[].sum)>1e-5)
   71 :          cout << "BUG :::   zero ==  " <<u1[].sum << endl;
   72 :    cout << " ---- " <<  i<< " " <<  v << endl;
   73 :    ur=real(eV[i]);
   74 :    ui=imag(eV[i]);
   75 : plot(ur,cmm="Eigen  Vector (real)  "+i+" valeur =" + v  ,wait=1,value=1);
   76 : plot(ui,cmm="Eigen  Vector (imag)  "+i+" valeur =" + v  ,wait=1,value=1);
   77 :
   78 :      // FFCS: add 3d view
   79 :     plot(eV[i],dim=3,fill=1);
   80 : } sizestack + 1024 =2920  ( 1896 )
 
  --  mesh:  Nb of Triangles =  23822, Nb of Vertices 12112
Complex eigenvalue problem: A*x - B*x*lambda
Complex eigenvalue problem: A*x - B*x*lambda
driver = 4 - sigma= (0,0)
 
Dimension of the system            : 48045
Number of 'requested' eigenvalues  : 2
Number of 'converged' eigenvalues  : 2
Number of Arnoldi vectors generated: 5
Number of iterations taken         : 6
 
Eigenvalues:
  lambda[1]: (3.36662e-15,2.64232e-13)
  lambda[2]: (5.86361,-0.00935005)
 
 ---- 0 (3.36662e-15,2.64232e-13)
  Plot::  Sorry no ps version for this type of plot 11
 ---- 1 (5.86361,-0.00935005)
  Plot::  Sorry no ps version for this type of plot 11
times: compile 0.146s, execution 14.582s,  mpirank:0
 ######## We forget of deleting   139 Nb pointer,   0Bytes  ,  mpirank 0, memory leak =0
 CodeAlloc : nb ptr  3993,  size :503408 mpirank: 0
Ok: Normal End
 try getConsole C:\Users\Bruney\Desktop\FreeFem\EigenvalueG\ChannelNonZeroK.edp
